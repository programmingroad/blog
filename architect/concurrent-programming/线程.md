### 应用之异步调用
从方法调用的角度来讲
- 需要等待结果返回，才能继续运行就是同步
- 不需要等待结果返回，就能继续运行就是异步

注意：同步在多线程中还有另外一层意思，是让多个线程步调一致

### 创建线程

- 使用Thread创建线程

```java
@Slf4j
public class Test1 {
    public static void main(String[] args) {
        Thread t1 = new Thread("t1") {
            @Override
            public void run() {
                log.debug("running");
            }
        };
        t1.start();
        log.debug("running");
    }
}
```
- 使用Runnable配合Thread创建线程

```java
@Slf4j
public class Test2 {
    public static void main(String[] args) {
        // 一个接口中只有一个抽象方法 并且 此接口用@FunctionalInterface注解标识 则可以使用lamda表达式
        Runnable r = () -> log.debug("running");
        Thread t1 = new Thread(r, "t1");
        t1.start();
        log.debug("running");
    }
}
```

- FutureTask配合Thread

```java
@Slf4j
public class Test3 {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        FutureTask<Integer> task = new FutureTask<>(() -> {
            log.debug("running");
            Thread.sleep(2000);
            return 100;
        });
        Thread t1 = new Thread(task,"t1");
        t1.start();
        // 等待task返回结果
        log.debug("{}",task.get());
    }
}
```

### Java
- jps 命令查看所有 Java 进程
- jstack <PID> 查看某个 Java 进程（PID）的所有线程状态
- jconsole 来查看某个 Java 进程中线程的运行情况（图形界面）

jconsole 远程监控配置需要以如下方式运行你的 java 类:

java -Djava.rmi.server.hostname=`ip地址` -Dcom.sun.management.jmxremote -
Dcom.sun.management.jmxremote.port=`连接端口` -Dcom.sun.management.jmxremote.ssl=是否安全连接 -
Dcom.sun.management.jmxremote.authenticate=是否认证 java类   


### 栈与栈帧
Java Virtual Machine Stacks （Java 虚拟机栈）
    
我们都知道 JVM 中由堆、栈、方法区所组成，其中栈内存是给谁用的呢？其实就是线程，每个线程启动后，虚拟
机就会为其分配一块栈内存。
- 每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存
- 每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法

### 线程上下文切换（Thread Context Switch）
因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码

- 线程的 cpu 时间片用完
- 垃圾回收
- 有更高优先级的线程需要运行
- 线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法

当 Context Switch 发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念
就是程序计数器（Program Counter Register），它的作用是记住下一条 jvm 指令的执行地址，是线程私有的

- 状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等
- Context Switch 频繁发生会影响性能

### 常见方法
    
方法名|static|功能说明|注意
---|---|---|---
start()|no|启动一个新线程，在新的线程运行 run 方法中的代码|start 方法只是让线程进入就绪，里面代码不一定立刻运行（CPU 的时间片还没分给它）。每个线程对象的start方法只能调用一次，如果调用了多次会出现IllegalThreadStateException
run()|no|新线程启动后会调用的方法|如果在构造 Thread 对象时传递了 Runnable 参数，则线程启动后会调用 Runnable 中的 run 方法，否则默认不执行任何操作。但可以创建 Thread 的子类对象，来覆盖默认行为
join()|no|等待线程运行结束
join(long n)|no|等待线程运行结束,最多等待 n毫秒
getId()|no|获取线程长整型的 id|id 唯一
getName()|no|获取线程名
setName(String)|no|修改线程名
getPriority()|no|获取线程优先级
setPriority(int)|no|修改线程优先级|java中规定线程优先级是1~10 的整数，较大的优先级能提高该线程被 CPU 调度的机率
getState()|no|获取线程状态|Java 中线程状态是用 6 个 enum 表示，分别为：NEW, RUNNABLE, BLOCKED, WAITING,TIMED_WAITING, TERMINATED
isInterrupted()|no|判断是否被打断，|不会清除 打断标记
isAlive()|no|线程是否存活（还没有运行完毕）
interrupt()|no|打断线程|如果被打断线程正在 sleep，wait，join 会导致被打断的线程抛出 InterruptedException，并清除 打断标记 ；如果打断的正在运行的线程，则会设置 打断标记 ；park 的线程被打断，也会设置 打断标记
interrupted()|yes|判断当前线程是否被打断|会清除 打断标记
currentThread()|yes|获取当前正在执行的线程
sleep(long n)|yes|让当前执行的线程休眠n毫秒,休眠时让出 cpu的时间片给其它线程
yield()|yes|提示线程调度器让出当前线程对CPU的使用|主要是为了测试和调试

### sleep
1. 调用 sleep 会让当前线程从 Running 进入 Timed Waiting 状态（阻塞）

```java
@Slf4j
public class Test6 {
    public static void main(String[] args) {
        Thread t1 = new Thread(){
            @Override
            public void run() {
                try {
                    Thread.sleep(2000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        };
        t1.start();
        log.debug("{}",t1.getState());
        try {
            Thread.sleep(500);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        log.debug("{}",t1.getState());
    }
}
```
2. 其它线程可以使用 interrupt 方法打断正在睡眠的线程，这时 sleep 方法会抛出 InterruptedException

```java
@Slf4j
public class Test7 {
    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(){
            @Override
            public void run() {
                log.debug("enter sleep...");
                try {
                    Thread.sleep(2000);
                } catch (InterruptedException e) {
                    log.debug("wake up...");
                    e.printStackTrace();
                }
            }
        };
        t1.start();
        Thread.sleep(1000);
        log.debug("interrupt...");
        t1.interrupt();
    }
}
```
3. 睡眠结束后的线程未必会立刻得到执行
4. 建议用 TimeUnit 的 sleep 代替 Thread 的 sleep 来获得更好的可读性
```java
@Slf4j
public class Test8 {
    public static void main(String[] args) throws InterruptedException {
        log.debug("enter");
        TimeUnit.SECONDS.sleep(1);
        log.debug("end");
    }
}
```
### yield
1. 调用 yield 会让当前线程从 Running 进入 Runnable 就绪状态，然后调度执行其它线程
2. 具体的实现依赖于操作系统的任务调度器

###  interrupt 方法详解

#### 打断 sleep，wait，join 的线程

打断阻塞的线程, 会清空打断状态，以 sleep 为例
```java
@Slf4j
public class Test9 {
    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(() -> {
            log.debug("sleep...");
            try {
                Thread.sleep(5000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            log.debug(" 打断状态: {}", Thread.currentThread().isInterrupted()); // 这里正常清除标记状态
        }, "t1");
        t1.start();
        Thread.sleep(3000);
        log.debug("interrupt");
        t1.interrupt();
        Thread.sleep(500); // 必须要睡眠一会才会清除标记状态？？？
        log.debug(" 打断状态: {}", t1.isInterrupted());
    }
}
```

打算正常运行的线程，不会清空打断状态且不会影响被打断的线程的运行
```java
@Slf4j
public class Test11 {
    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(() -> {
            while (true) {
                if (Thread.currentThread().isInterrupted()) {
                    log.debug("被打断了");
                    break;
                }
            }
        }, "t1");
        t1.start();
        Thread.sleep(1000);
        log.debug("interrupt");
        t1.interrupt();
    }
}
```

### 两阶段终止模式
在一个线程T1中如何【优雅】的终止线程T2，这里的【优雅】指的是给T2一个料理后事的机会
```java
public class Test12 {
    public static void main(String[] args) throws InterruptedException {
        TwoPhaseTermination tpt = new TwoPhaseTermination();
        tpt.start();
        Thread.sleep(5000);
        tpt.stop();
    }
}

@Slf4j
class TwoPhaseTermination {
    private Thread monitor;

    public void start() {
        monitor = new Thread(() -> {
            while (true) {
                Thread currentThread = Thread.currentThread();
                if (currentThread.isInterrupted()) {
                    log.debug("料理后事");
                    break;
                }
                try {
                    Thread.sleep(1000);
                    log.debug("执行监控");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                    // 重新设置打断标记 打断sleep的线程会清空打断标记
                    currentThread.interrupt();
                }
            }
        });
        monitor.start();
    }

    public void stop() {
        monitor.interrupt();
    }
}
```

#### 打断park线程

```java
@Slf4j
public class Test13 {
    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(() -> {
            log.debug("park...");
            // 只有打断标记为false的时候才生效
            LockSupport.park();
            log.debug("unpark...");
            // 不会清除打断状态
//            log.debug("打断状态={}", Thread.currentThread().isInterrupted());
            // 会清除打断状态
            log.debug("打断状态={}", Thread.interrupted());
            LockSupport.park();
            log.debug("unpark...");
        }, "t1");
        t1.start();
        Thread.sleep(1000);
        t1.interrupt();
    }
}
```

### 线程的状态
#### 从操作系统层面来描述（五种状态）
- 初始状态：仅是在语言层面创建了线程对象，还未与操作系统线程关联
- 可运行状态：（就绪状态）指该线程已经被创建（与操作系统线程关联），可以由cpu调度执行
- 运行状态：指获取了cpu时间片运行中的状态
    - 当cpu时间片用完，会从【运行状态】转换至【可运行状态】，会导致线程的上下文切换
- 阻塞状态：
    - 如果调用了阻塞 API，如 BIO 读写文件，这时该线程实际不会用到 CPU，会导致线程上下文切换，进入【阻塞状态】
    - 等 BIO 操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】
    - 与【可运行状态】的区别是，对【阻塞状态】的线程来说只要它们一直不唤醒，调度器就一直不会考虑
      调度它们
- 终止状态：表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态

#### 从JAVA API层面来描述（六种状态）
- NEW 线程刚被创建，但是还没有调用 start() 方法
- RUNNABLE 当调用了 start() 方法之后，注意，Java API 层面的 RUNNABLE 状态涵盖了 操作系统 层面的
【可运行状态】、【运行状态】和【阻塞状态】（由于 BIO 导致的线程阻塞，在 Java 里无法区分，仍然认为
是可运行）
- BLOCKED ， WAITING ， TIMED_WAITING 都是 Java API 层面对【阻塞状态】的细分，后面会在状态转换一节
详述
- TERMINATED 当线程代码运行结束
```java
@Slf4j
public class TestState {

    public static void main(String[] args) throws IOException {
        Thread t1 = new Thread("t1") {
            @Override
            public void run() {
                log.debug("running...");
            }
        };

        Thread t2 = new Thread("t2") {
            @Override
            public void run() {
                while (true) { // runnable

                }
            }
        };
        t2.start();

        Thread t3 = new Thread("t3") {
            @Override
            public void run() {
                log.debug("running...");
            }
        };
        t3.start();

        Thread t4 = new Thread("t4") {
            @Override
            public void run() {
                synchronized (TestState.class) {
                    try {
                        Thread.sleep(1000000); // timed_waiting
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        };
        t4.start();

        Thread t5 = new Thread("t5") {
            @Override
            public void run() {
                try {
                    t2.join(); // waiting
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        };
        t5.start();

        Thread t6 = new Thread("t6") {
            @Override
            public void run() {
                synchronized (TestState.class) { // blocked
                    try {
                        Thread.sleep(1000000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        };
        t6.start();

        try {
            Thread.sleep(500);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        log.debug("t1 state {}", t1.getState()); // NEW
        log.debug("t2 state {}", t2.getState()); // RUNNABLE
        log.debug("t3 state {}", t3.getState()); // TERMINATED
        log.debug("t4 state {}", t4.getState()); // TIMED_WAITING
        log.debug("t5 state {}", t5.getState()); // WAITING
        log.debug("t6 state {}", t6.getState()); // BLOCKED
    }
}
```